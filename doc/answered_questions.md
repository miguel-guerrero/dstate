

## WHAT ARE THE ADVANTAGES OF USING dstate VS WRITING MY OWN FSMS

Use the right tool for the right problem. This is where dstate is a
good fit:

- Your code is control intensive. You need good control of what happens
  on each clock cycle boundary.

- Your code may come from a complex algorithm with losts of control
and math, however a CPU is not the right thing.

If your code meets the above conditions, what dstate offers is higher level
of abstraction that will allow you to work with more readable code. This 
reverts in higher productivity (typically the code entered is 2.5x smaller
than the FSM equivalent) and lower chances of introducing bugs.


## HOW IS dstate DIFFERENT FROM HLS (HIGH LEVEL SYNTHESIS)

* There are several flavors of HLS but in the most common one, you 
provide constraints to the HLS tool, and it tries to meet them. You don't
have full control on the logic exactly at each clock boundary level. If 
this is the type of HLS tool you are using, *dstate* can be a complement
where that level of detailed control is needed.

* You or your company cannot afford a 6 figure investment on an HLS tool.
dstate is free / open source with no strings attached to your design.


## WHY ARE THE INPUTS STRUCTURED THIS WAY

Initially the contents of the BLOCK within SmForever and SmEnd
gets internally converted:

    SmBegin

        DECLS

    SmForever

        BLOCK

    SmEnd

into the following:
    
    DECLS

    while(1) begin
        tick;
        BLOCK
    end

I.e. The block is forced to become an infinite loop with a clock
edge at the very top. This ensures real HW behavior.

The DECLaration block is analyzed to extract initial values for 
variables. Those will help on the reset logic generation.


## WHY ONLY BLOCKING ASSIGNEMENTS

BLOCK is expected to contain only blocking assignements.

This is, in my opinion, the biggest productivity boost dstate provides.
Typically the original algorithm is very sequential. When a variable gets
a value it does so immediately so if, for instance, you compare it with another 
value right after, t is expected to be based on the newly assigned value.

In HW we are used to setting the value of flops to be taken on the next 
clock cycle. This introduces possibilities of error during the conversion 
and forces lowering the level of abstraction at which you find yourself working.

dstate code is converted into a combinational block on one side and then
state variables are captured for the next cycle separately. 


## HOW IS THE CODE CONVERTED TO AN FSM

The control structure of the code is converted into a directed graph with
all possible execution paths. At this point the difference between them
(if/while/do/for/case/...) blurries. Think of it as just goto statements 
that can flow forward or backwards.

Special attention is given to the *tick*statements. A *tick*statement demarks
the beginning of the code associated to a state. The graph is transversed 
from each *tick*statement for all possible paths until they end in a *tick*
statement as well. Every time a tick statement is reached, a transition to its
associated state is generated. Code is generated by looking at the path from
each *tick* statement and dumping out what is found on the way to any other
tick statements (or itself). 

Finally state merging is done. States are compared for structural equality
and merged if identical.


## CAN I HAVE LOOPS WITH NO tick INSIDE?

If the loop contains no *tick* is fine (as long as it is synthesizable).
However if it contains a tick conditionally (may be under a nested if) then
it must be ensured that there is no zero clock-edge (tick) possible looping
path.

E.g. this is ok:

    tick
    if (cond) begin
        for (init; cond2; incr) begin
            ...
        end
    end
    tick

In this case the for loop must be synthesizable by the target synthesis
tool itself (it has to have compile time inferable number of iterations
and comply with synthesis tool requirements). I.e. the loop is emitted
as-is to the output.

however:

    while(cond) begin
        if (cond2) begin
            stm1;
            tick;
            smt2
        end
        stm3;
    end

is currently unsuported as if cond2 is false we'll have a loop
that is iterating completly without clocks in between

whereas:

    while(cond) begin
        if (cond2) begin
            stm1;
            tick;
            smt2
        end
        stm3;
        tick; // ADDED
    end

and

    while(cond) begin
        if (cond2) begin
            stm1;
            tick;
            smt2
        end
        else begin // ADDED
            stm3;
            tick; // ADDED
        end
    end

Are both OK as the loop has a guaranteed clock boundary between iterations


## HOW IS THE CODE PARSED 

Parsing is done only up to the level of detail required. dstate looks for control
structures that define the flow of execution. The contents of a basic
sentence is preserved as-is and looked only for the information required,
not parsed to full detail. 

For instance when parsing and if statement, the condition is captured from beginning
to end of the parenthesis surrounding it (matching levels) but not parsed
in detail. The associated code is used generally as-is or in inverted form.
Syntax errors, if any, at this level will be captured by the tool using the 
generated code later on, but not itself by dstate.

This approach allows keeping parsing complexity low and still be reliable on the
details required. The parser is a recursive-descent top-down parser.


## HOW IS THIS COMPATIBLE WITH MY FLOW

If your flow is pure Verilog/SystemVerilog based, the only thing you need to do
is to pass your input files through:

1. A Verilog preprocessor. dstate does not expand preprocessor macros, and they can
be very helpful to increase abstraction (think of time consuming macros like wait until
a condition is true). We tested with vppreproc
2. dstate

The output should be at this point the entry point to your original flow.

If your flow includes more code generators it would have to be inserted at the right
place to make it compatible with them.

# HOW IS IT TESTED

Most of the tests compare the generated FSM version with a behavioral version (see --behav)
that is basically the input code with only trivial transformations (adding variable suffixes) and 
just some wrapping logic around it. The purpose of the testing is to make sure the conversion is correct 
(not that the original design did the right thing) so in most cases the outputs are compared to each other.

Some examples have checkers for absolute functionality (e.g _matmul_simple_ and _matmul_fast_ examples)

To make sure the code is synthesizable, **yosys** open source sinthesizer has been used, comparing the 
functionality of the lower gate-level like representation (generic technology) with the RTL version of it.
This step is optional and can be invoked doing 'make gls' under a given example/test directory.


